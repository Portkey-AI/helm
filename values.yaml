# Default values

portkey:
  labels: {}
  annotations: {}

# -- Provide a name in place of `portkey`
nameOverride: ""
# -- String to fully override `"portkey.fullname"`
fullnameOverride: ""
# -- Annotations that will be applied to all resources created by the chart
commonAnnotations: {}
# -- Labels that will be applied to all resources created by the chart
commonLabels: {}
# -- Common environment variables that will be applied to all deployments/statefulsets created by the chart. Be careful not to override values already specified by the chart.
commonEnv: []

imageCredentials:
  - name: portkeyenterpriseregistrycredentials
    create: true
    registry: https://index.docker.io/v1/
    username: ayush@portkey.ai
    password: quk@naw4HYP@dfp5mna
imagePullSecrets: [portkeyenterpriseregistrycredentials]

images:
   # -- Secrets with credentials to pull images from a private registry. Specified as name: value.
  
  backendImage:
    repository: "docker.io/portkeyai/backend"
    pullPolicy: IfNotPresent
    tag: "ag-23"
  frontendImage:
    repository: "docker.io/portkeyai/frontend"
    pullPolicy: IfNotPresent
    tag: "ag-11"
  mysqlImage:
    repository: "docker.io/mysql"
    pullPolicy: IfNotPresent
    tag: "8.1"
  redisImage:
    repository: "docker.io/redis"
    pullPolicy: IfNotPresent
    tag: "alpine"
  clickhouseImage:
    repository: "docker.io/clickhouse/clickhouse-server"
    pullPolicy: IfNotPresent
    tag: "latest"

ingress:
  enabled: true
  hostname: "app.pk.ai"
  subdomain: "app"
  ingressClassName: "nginx"
  annotations: {}
  labels: {}
  tls: []

apiIngress:
  enabled: true
  hostname: "albus.pk.ai"
  subdomain: "albus"
  ingressClassName: "nginx"
  annotations: {}
  labels: {}
  tls: []

config:
  existingSecretName: ""
  defaultGatewayURL: ""
  
  noAuth:
    enabled: true
    jwtPrivateKey: "LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2QUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktZd2dnU2lBZ0VBQW9JQkFRQ3p2RkpTY0FQbEFTeEMKdHdFeEVhNGdMc2puTzZjWFIweDJHSlRQSVFPNVI0Qm5jcFgyT0dNcTNYUVRMdFhaSzRjVmZXWkZIcVRMQXFMcwoxQmZ2RHFFZjNwZmlqRUkxQkVFYVV0dk1iVTE4WmdhRStKVmRrZVdBODFvT05rR3pvKzRJT01EY3preGZFdEYyClNKbkNxc0QvTG1yRHhueWZ3Yy9HNDRKdTlBRGgwTmZGaDRzZkVTNHAxOXE0UHJ6eHJUcXI0a3QxTmx3bURLQkgKazBEVXhMTGpOWWorL3VNTE1NOWZLRGZBeUJYWWpWS1FZVDJTa2JxblBUTEpsbldRZzM1UWt0cS9pYkNWbEdaOQpMRmNYNEV4WTYweVAyek9xeHZJQlVEUHRQTzJEU2pWT2FoQ2dwN1ArQ3FHT0QwNXdYd3NkU2JIVWQ4M3ZBc1JRClYxdkZQT2RGQWdNQkFBRUNnZ0VBSEtKdkZ4VWplYk9ESXFuWE5jTVVVNnBBZFo1cVUyb1hnMlVOS0NhaFdqNUsKOWJBcXRneHJ1Q09KMzVpQmwxUzQ4N0tEdlpWUk9jcVV2RmhaNjhzUDNtenZFN2Uyd0kySjliQ250ZHpnRUdhTQp1VmlGSzJBWUNVQTc0N0cvSytoOC9yQlVBWm1ZVHpsSFI2bnZYVFVwQkQ2WDRkTFlmZmM1cS8wSkJiWTRBY0duCnV0MTgrdW9MeHhWcDlhaUtZNnpNTHJnamVFMXhZYTk1b3JwUVF1TG91WlJpQUNRQWh0VmNTSDY3c3c5TkFRYlEKeVBnTXI3MGRUSDlkWkx5STh2ZWlhQXZUYVdnaTZIdXJZa2hpa05sU05FWlNCOTUvYjZDM3lmcEVqckV6Q1lhZwpnTzIzZmxIS2lZMnlXTjQwY1hBalZ4YTJjMHNRSzQwVXVSOUdXUWF5N1FLQmdRRDdNUXBxK1ZrYWhxazYrV09kCkc1MGozVFQ4RmxGZndsSjVlWUNrT2tRVFc4MVVmUyt6M0VqbG5iOWRhY1lVQjh2YmFiSEg2Rk9wcm5sS1NhUGQKdXNnSlluL29VN3VhOFYyNXduV3FucnVmT2ZUVU1VbmRScStYWnpwejJDS2pYYlc3NldXZTh0ZG5mYW1Ia0ZRcAoyMEpoeGlVRllOWkNZZnYzVFJiWXNuRWJ2d0tCZ1FDM0xSekxtTTh1VDRVQW5nTmJ3VEZkVDMyUlJDV05LMkw2CnlmUnQ4SUtMandlY2s0TURSak9UTlR4U2RsRjRnS2hRVjkrKzFZWGJMK3FISWlwT3J1ZWhYYURtTGptZHJrQ0kKMWNtME55UkNGUVVUYTlIRDQzWlVTSlZWS0VIOStVNnhkSTZNTlJPVTY5MFlXK3NlVUg2THNST2VzbEFWSW9rYwpjc21vZ1pJTit3S0JnR2kwZW5rNDB2R0JyRTBPNDN6N283YnRZRWFzTHVOUnB2dEhzRjNFZzlmbDdtTUhnN2pmClcrdUtvOWdXWFNEQVZ6TndqVkNkQVRLN3JZZFB4dVNJRlJZRVh2akMzbktwcGIzbTF4RjE5Uk5jSHpmTUM5UVcKd043Rmd0SURCLzA4OUtJTm1mUjFtV0JrT3lScy93Z3JneklxWEFndjQxL3NaQkVqcXlCTTBXVVZBb0dBT3RvRApwbVl5S203aURKQzRBNExPbVd3d3E3dDVWU0hiYXpmM2tGcjFsbUVkMFBDVDV6bG0yS1VCL0h5SE1IQWxvNnFYCitIZ2h5WXBiajQ4cWlKMHBUbThHZ3UzWEZSSW5LYytHUHFCNHhjSjdId0pGSXVxeDJlSjRHQ1FYRDhKSnhqbnMKa3A5NjZ4M2NxemJkRTZCSkNCaWNkU0JWR25VK0dDWEpKSnA4a29FQ2dZQTh2VGJlKzBiL2taT2xYd2g4RzczSApjUnVIOUdXK3BBUkNlWkp0c053S296dVp3VEhuMzlvWDVtTjIvdDZPN0hiSmUvZEdXRVN3Z3FTWUkzaXBGOW9qCkRReXIxQW9kMmNlM0xqbGpBUUZpdHdBWERXWUg1MjM2Q2JxcmFRNUtwdFFDQzdyVTVOcUVlRnRURDRpVXUwZ00KT2tFMkZ5L0V6UktUVWhVU0VuMm9hdz09Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K"
    jwtPublicKey: "LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFzN3hTVW5BRDVRRXNRcmNCTVJHdQpJQzdJNXp1bkYwZE1kaGlVenlFRHVVZUFaM0tWOWpoakt0MTBFeTdWMlN1SEZYMW1SUjZreXdLaTdOUVg3dzZoCkg5Nlg0b3hDTlFSQkdsTGJ6RzFOZkdZR2hQaVZYWkhsZ1BOYURqWkJzNlB1Q0RqQTNNNU1YeExSZGtpWndxckEKL3k1cXc4WjhuOEhQeHVPQ2J2UUE0ZERYeFllTEh4RXVLZGZhdUQ2ODhhMDZxK0pMZFRaY0pneWdSNU5BMU1TeQo0eldJL3Y3akN6RFBYeWczd01nVjJJMVNrR0U5a3BHNnB6MHl5Wloxa0lOK1VKTGF2NG13bFpSbWZTeFhGK0JNCldPdE1qOXN6cXNieUFWQXo3VHp0ZzBvMVRtb1FvS2V6L2dxaGpnOU9jRjhMSFVteDFIZk43d0xFVUZkYnhUem4KUlFJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg=="

  oauth:
    enabled: false
    oauthClientId: ""
    oauthIssuerUrl: ""
    oauthClientSecret: ""
    oauthRedirectURI: ""

  smtp:
    enabled: false
    smtpHost: ""
    smtpPort: ""
    smtpUser: ""
    smtpPassword: ""
    smtpFrom: ""

  
# -- Log storage configuration
# Used to store raw inputs & outputs of all requests going through portkey
# We support all S3 and mongo compliant store, AWS s3, Azure blob storage, and GCS, R2, Wasabi, NetApp,etc and MongoDB, AWS DocumentDB
# You can also use s3 via AWS IAM Assume Role if you s3 buckets are in a different account.
# logStorage:
  logStorageType: ""
  # -- S3 specific configuration
  s3:
    enabled: true
    AWS_ACCESS_KEY_ID: ""
    AWS_SECRET_ACCESS_KEY: ""
    AWS_REGION: ""
    AWS_BUCKET_NAME: ""
  mongo:
    enabled: false
    MONGO_URI: ""
    MONGO_DB: ""
    MONGO_COLLECTION: ""
  s3-assume:
    enabled: false
    AWS_ACCESS_KEY_ID: ""
    AWS_SECRET_ACCESS_KEY: ""
    AWS_REGION: ""
    AWS_BUCKET_NAME: ""
    AWS_ASSUME_ROLE_ACCESS_KEY_ID: ""
    AWS_ASSUME_ROLE_SECRET_ACCESS_KEY: ""
    AWS_ASSUME_ROLE_REGION: ""

backend:
  name: "backend"
  containerPort: 8080
  deployment:
    autoRestart: true
    replicas: 1
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources:
      limits:
        cpu: 1000m
        memory: 1Gi
      requests:
        cpu: 200m
        memory: 500Mi
    startupProbe:
      httpGet:
        path: /health
        port: 8080
      initialDelaySeconds: 60
      failureThreshold: 3
      periodSeconds: 10
      timeoutSeconds: 1
    livenessProbe:
      httpGet:
        path: /health
        port: 8080
      failureThreshold: 3
      periodSeconds: 10
      timeoutSeconds: 1
    readinessProbe:
      httpGet:
        path: /health
        port: 8080
      failureThreshold: 3
      periodSeconds: 10
      timeoutSeconds: 1
    extraContainerConfig: {}
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
  service:
    type: ClusterIP
    port: 8080
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80

clickhouse:
  name: "clickhouse"
  external:
    # If enabled, use the following values to connect to an external database. This will also disable the
    # creation of a clickhouse stateful-set and service.
    enabled: false
    host: ""
    port: "8123"
    nativePort: "9000"
    user: "default"
    password: "password"
    database: "default"
    tls: false
    existingSecretName: ""
  containerHttpPort: 8123
  containerNativePort: 9000
  statefulSet:
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources:
      limits:
        cpu: 1000m
        memory: 2Gi
      requests:
        cpu: 500m
        memory: 1Gi
    command:
      - "/bin/bash"
      - "-c"
      - "sed 's/id -g/id -gn/' /entrypoint.sh > /tmp/entrypoint.sh; exec bash /tmp/entrypoint.sh"
    startupProbe:
      httpGet:
        path: /ping
        port: 8123
      failureThreshold: 6
      periodSeconds: 10
      timeoutSeconds: 1
    readinessProbe:
      httpGet:
        path: /ping
        port: 8123
      failureThreshold: 6
      periodSeconds: 10
      timeoutSeconds: 1
    livenessProbe:
      httpGet:
        path: /ping
        port: 8123
      failureThreshold: 6
      periodSeconds: 10
      timeoutSeconds: 1
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    # We recommend using a persistent volume and increasing the storage size to something like 50Gi when using in a production environment!
    persistence:
      enabled: true
      size: 2Gi
      storageClassName: "standard"
  service:
    type: ClusterIP
    httpPort: 8123
    nativePort: 9000
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}

frontend:
  name: "frontend"
  containerPort: 80
  defaultGatewayURL: ""
  deployment:
    autoRestart: true
    replicas: 1
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources:
      limits:
        cpu: 1000m
        memory: 1Gi
      requests:
        cpu: 200m
        memory: 500Mi
    # startupProbe:
    #   httpGet:
    #     path: /
    #     port: 80
    #   failureThreshold: 10
    #   periodSeconds: 10
    #   timeoutSeconds: 10
    # livenessProbe:
    #   httpGet:
    #     path: /
    #     port: 80
    #   failureThreshold: 10
    #   periodSeconds: 10
    #   timeoutSeconds: 10
    # readinessProbe:
    #   httpGet:
    #     path: /
    #     port: 80
    #   failureThreshold: 10
    #   periodSeconds: 10
    #   timeoutSeconds: 10
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
  autoscaling:
    enabled: false
    # If enabled, use the following values to configure the HPA. You can also use your own HPA configuration by not creating an HPA.
    # You may want to manage the HPA yourself if you have a custom autoscaling setup like KEDA.
    createHpa: true
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
  service:
    type: LoadBalancer
    httpPort: 80
    httpsPort: 443
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}

mysql:
  name: "mysql"
  external:
    # If enabled, use the following values to connect to an external database. This will also disable the
    # creation of a mysql stateful-set and service.
    enabled: false
    host: ""
    port: "3306"
    user: "portkey"
    password: "portkey@123"
    database: "portkey"
    existingSecretName: ""
    # Use this to set the root password for the mysql instance, only when NOT using an external Mysql.
    rootPassword: "portkey@123"
  containerHttpPort: 3306
  containerNativePort: 3306
  containerPort: 3306
  statefulSet:
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources:
      limits:
        cpu: 2000m
        memory: 4Gi
      requests:
        cpu: 1000m
        memory: 2Gi
    command: []
    startupProbe:
      exec:
        command:
          - /bin/sh
          - -c
          - mysqladmin ping -u${MYSQL_USER} -p${MYSQL_PASSWORD}
      initialDelaySeconds: 10
      failureThreshold: 6
      periodSeconds: 10
      timeoutSeconds: 5
    readinessProbe:
      exec:
        command:
          - /bin/sh
          - -c
          - mysqladmin ping -u${MYSQL_USER} -p${MYSQL_PASSWORD}
      failureThreshold: 6
      periodSeconds: 10
      timeoutSeconds: 1
    livenessProbe:
      exec:
        command:
          - /bin/sh
          - -c
          - mysqladmin ping -u${MYSQL_USER} -p${MYSQL_PASSWORD}
      failureThreshold: 6
      periodSeconds: 10
      timeoutSeconds: 1
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
    persistence:
      enabled: true
      size: 2Gi
      storageClassName: "standard"
  service:
    type: ClusterIP
    port: 3306
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}

redis:
  name: "redis"
  external:
    # If enabled, use the following values to connect to an external redis instance. This will also disable the
    # creation of a redis stateful-set and service.
    enabled: false
    connectionUrl: "redis://localhost:6379"
    tlsEnabled: "false"
    mode: "standalone"
    store: "redis"
    existingSecretName: ""
  containerPort: 6379
  statefulSet:
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources:
      limits:
        cpu: 4000m
        memory: 16Gi
      requests:
        cpu: 1000m
        memory: 2Gi
    command: []
    startupProbe:
      exec:
        command:
          - /bin/sh
          - -c
          - exec redis-cli ping
      failureThreshold: 6
      periodSeconds: 10
      timeoutSeconds: 1
    readinessProbe:
      exec:
        command:
          - /bin/sh
          - -c
          - exec redis-cli ping
      failureThreshold: 6
      periodSeconds: 10
      timeoutSeconds: 1
    livenessProbe:
      exec:
        command:
          - /bin/sh
          - -c
          - exec redis-cli ping
      failureThreshold: 6
      periodSeconds: 10
      timeoutSeconds: 1
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
    persistence:
      enabled: false
      size: 8Gi
      storageClassName: ""
  service:
    type: ClusterIP
    port: 6379
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}